package main

import (
	"fmt"
	"math"
)

const epsilon = 0.000001 //매우작음


func equal(a,b float64) bool {

	//비트쪽으로 얘기하면 길어지기때문에 패스를 하고
	//실수를 어떻게 처리할것이냐 가장좋은방법은 1bit 단위로 처리하는것이 가장좋다
	//지수부와 실수부로 나누어진다.
	//가장 바깥쪽에 있는 오른쪽에 있는 비트 그 bit를 비교하는것이 가장 좋다.
	//가장 마지막 bit가 1bit가 차이나는걸 어찌 아느냐??
	//math.Nextafter :  Nextafter매개변수를 2개받고 리턴은 64bit float타입을 리턴한다.
	//함수동작은 매개변수 xy를 향해서 1bit만 조정한 값을 리턴해준다. 매개변수 2개를 딱 넣으면
	//x가 y보다 작으면 x에서 1bit만큼 증가를 시켜주고 x에서 1bit만큼 감소시킨값을 리턴해준다.
	//가장작은 오차만큼을 y를 향해서 더하거나 빼준다. 한마디로 함수를 써가지고 실수값 대소비교할때 써준다.
	

	//근데 사실 잊지말아야할것 어디까지나 이방법은 오차를 무시하는 방법 //엄청나게 작은값을 무시하는것 엄밀히따지면 무시하는것
	//만약에 제작하는 프로그램이 금융쪽프로그램이다. math안에 빅이라는 매서드를 사용하면 더정확한 수치계산을 할 수 있다.

	return math.Nextafter(a,b)==b
	// if a>b{
	// 	if a-b <=epsilon{
	// 		return true
	// 	}else{
	// 		return false
	// 	}
	// }else{
	// 	if b-a <=epsilon{
	// 		return true
	// 	}else{
	// 	return false
	// }

	// }
}

func main(){

	// var a int = 10
	// var b int = 20
	// //float은 소수점이하 6자리까지 표현을 한다.
	// //%d가 십진수 이상으로 적어주는 녀석?????
	// var f float64 = 123213213.546

	// fmt.Println("Hellow World")
	// //서식문자 : %d / 변수 : a,b,f 
	// fmt.Printf("a : %d\\ b: %d\t f: %f\n", a,b,f)
	//변수는 차례대로 들어간다 a부터 f까지
	// // : 역슬레시 자체를 출력해준다.  /tep 텝키 텝이다. 띄어줜다.
	

	var str string = "H\nellow\t\tWor\\l\"d\""
	fmt.Println(str)
	//	fmt.Println(str)->H/nellow                Wor\l"d" 
	// \"\"" : 더블쿼터를 표현해줌  Wor\l"d" 
	// \\ 역슬레이스 표현해줌 Wor\l"d" 
	// \t H/nellow                Wor\l"d" 간격을 떨어트려줌
	// \n은 앞에 문자열을 지워준다. ellow           Wor\l"d"


	/////////////////////////////////////////////////////////////////////////////////////////

	// var input int32
	// var input1 int32

	//입력을 받는다. 인자로는 해당 변수의 메모리주소.
	//스켄이나 scanf를 써서 받아주면된다.
	// fmt.Scan(&input, &input1)


	/////////////////////////////////////////////////////////////////////////////////////////

	// 비트연산 : [&, |, ^, &^]  
	//            [AND, OR, XOR, 비트클리어]

	// 시프트연산 <<(왼쪽), >>(오른쪽)

	// //왼쪽으로 비트를 한칸씩 옮긴다. 
	// 00000001 <<1
	// 00000010 이렇게 변환된다.!!
	// //왼쪽으로 비트를 두칸씩 옮긴다. 
	// 00000001 <<2
	// 00000100 이렇게 변환된다.!!

	///////////////////////////////////////////////////////////////////////////////////////////////////////

	/*
	AND연산 (&의 조건 둘다 1일때만 1이다.)
	A	B	A&B 
	------------------
	0	0	0
	1	0	0	
	0	1	0
	1	1	1
	------------------
	
	10 & 34 = 2
	
	0000 1010 => 10
	
		AND(&)

	0010 0010 => 34
	0000 0010 => 2

	*/

	/*
	OR
	A	B	OR
	------------------
	0	0	0
	1	0	1	
	0	1	1
	1	1	1
	------------------
	
	0000 1010 => 10
	
		OR(|)

	0010 0010 => 34
	0010 1010 => 42

	

	//XOR
	
	XOR(A,B가 다르면 1) 
	A	B	XOR
	------------------
	0	0	0
	1	0	1	
	0	1	1
	1	1	0
	------------------
	
	0000 1010 => 10
	
		A^B

	0010 0010 => 34
	0010 1000 => 40
	
	*/


	//비교연산자
	/*
	비교연산자 이건 내가 자습할때 한번 예시를 만들어보자!!
	==, !-, <,>, <=,>=

	*/

	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	var a float64 = 0.1
	var b float64 = 0.2
	var c float64 = 0.3	

	fmt.Printf("%0.18f + %0.18f = %0.18f \n", a, b, a+b)
	//0.100000000000000006 + 0.200000000000000011 = 0.300000000000000044 
	fmt.Printf("%0.18f == %0.18f : %v\n", c, a+b, equal(a+b, c))
	//0.299999999999999989 == 0.300000000000000044 : true
	//%0.18 = 소수점 18번째자리까지 표현하게끔해줘라 
	//C값도 0.300000000000000044 값이 결국 equal보다 작기때문에 트루로 나타내어준다.
	//물론 더 좋은 함수가 있다. -> 페키지중에 이러저러한 녀석이 있는데 

	///////////////////////////////////////////////////////////

	// var fa float64 = 0.1
	// var fb float64 = 0.2
	// var fc float64 = 0.3	

	// fmt.Printf("%f+%f==%f : %v\n", fa,fb,fc, fa+fb ==fc)
	// //0.100000+0.200000==0.300000 : false 0.3에대한 정확한 값을 표현할수 없다 2진수로 이러한 값들을 무시하게끔 한다. -> 입실론 값을 준다 정해놓는다.
	// fmt.Println(fa + fb)
	// // 0.30000000000000004

	//컴퓨터가 실수를 할때 지수부 소수부 나눠서 표현함 10진수가 아닌 2진수 표현을 함 10진수 소수를 졍확히 표현을 한다.
	//컴퓨터는 바이너리 표현 이진수만 쓴다. 분명한 오차가 생긴다. 
	

	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


	//&&, ||, !, 논리연산자 자습으로 공부할것 

	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	//대입연산자 자습으로 공부할것

	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	//층간연산자??? ++ --??

	//[] 배열의 요소에 접근할때

	//.구조체에 접근하는 접근연산자

	//&메모리 주소 접근하는거

	//...슬라이스 요소에 접근하거나 하는것

	//: 배열의 일부분을 가져올때 쓴다.


	//예를들

	var test int8 = 30
	//비트밀었다.
		test<<=2
	    test+=8
	println(test)

	//0000 0000
	//128,64,32,16,8,4,2,1
	//0001 1110 = 30

	//0111 1000
	//120





}	
/*

//////////////////////////////////////////////////////////////////////////////////////////////////////

	%T : 데이터 타입 출력
	%t : 불리언을 true / false 출력
	%d : 10진수 정수값으로 출력 
	%b : 2진수로 출력해준다. ->바이너리 b
	%c : 유니코드 문자를 출력해준다. (정수타입만 가능하다???..)
	%X : 16진수로 출력 10넘어가면 대문자로 표현
	%x : 16진수로 출력 10넘어가면 소문자로 표현
	%e : 지수형태로 실수값을 표현해준다. -> -1.312312321e+65
	%s : 문자열을 출력 
	%p : 메모리 주소값을 출력

//포맷 : fmt 페키지


//프린트는 일자로 뿌려주는것 콘솔같은 느낌이다. 프린트 Ln은 대행해주는 느낌

// fmt.Printf("a : %d b: %d ") -> %d를 서식 문자라고 한다.
// 서식문자 : %d


///////////////////////////////////////////////////////////////////////////////////////////////////////











*/