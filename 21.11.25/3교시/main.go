package main

import "fmt"

type Data struct{
	value int
	data [200] int 
	//1608bite
}
//복사하고있는것이다. Data변수값이 모두 복사가 된다. -> 다른공간으로 배정된다??

func ChangeData(d Data)  {
	//매개변수로 Data를 받았다??
	
	d.value = 100
	//아규먼트는 d라고생각하면된다.
	d.data[100] = 200
	//data는 다른위치에 있다고생각하면된다.

}
//매개변수로 Data 포인터를 받는다.
//포인터 변수다.!!
func POinterChange(d *Data){
	
	d.value = 100
	//아규먼트는 d라고생각하면된다.
	d.data[100] = 200
	//data는 다른위치에 있다고생각하면된다.

}

func main() {
	//포인터 : 메모리주소를 값으로 반환하는 타입

	var p *int // p는 int타입 데이터 주소를 가르키는 포인터 변수
	//포인터는 메모리 주소를 값으로 가지기 때문에...숫자... 뭐 이런거 안됨??왜안됨??

	//&레퍼런스를 붙인다??뭘가지려면 몰라
	var a int = 100
	//a의 메모리주소를 포인터변수 p에 대입(복사)
	p = &a

	println("포인터 변수 p의 값(a의 메모리주소)", p)
	//포인터 변수 p의 값(a의 메모리주소) 0xc000039f60

	//역참조를 하면된다고한다???
	//역참조를 하면 그안에 값을 가져올수 있다고했다.
	println("p가 가르키는 메모리의 값:", *p)
	//p가 가르키는 메모리의 값: 100

	//월세 세입자가 만기가되가지고 101호에가가지고 새로운 새입자가 들어가는것이다.
	*p = 300
	println("값 변경후 a의 값", *p)
	//값 변경후 a의 값 300

	//== 비교연산자를 써서 같은공간의 메모리카드를 가르키고있냐라는것을 알수 있다.
	//포인터 변수 값 비교하기

	var x int = 20
	var y int = 10

	var p1 *int = &x	//x의 메모리공간
	var p2 *int = &x	//x의 메모리공간
	var p3 *int = &y	//y의 메모리공간

	fmt.Printf("p1,==p2 : %v\n, ",p1==p2)
	//p1,==p2 : true
	//p1과 p2는 x라는 같은공간안에 넣어줬다.
	fmt.Printf("p2,==p3 : %v\n, ",p2==p3)
	//p2과 p3는 x와 y라는 다른공간안에 넣어줬다.
	//p2,==p3 : false

	//nil(null) = 0과 같다. 
	//포인트 변수는 초기화를 하지 않으면 default value는 nil(null) = 
	//0이긴 하지만 유효하지 않는 메모리 주소값, -> 어떠한 공간도 가르키고 있지않다.
	

	// var pointer* int 


	// if pointer !=nil {
	// 	//포인터 변수가 nil이 아니라면 -> 유효한 메모리 주소를 가리킨다.
	// }
	
	// 그래서 포인터는 왜쓰는가??
	// 대입이나 인수 전달시 값을 복사하기 때문에 성능상에 이슈발생.
	// 다른공간에 복사하기 때문에 변경사항이 적용x
	
		//포인터를 이용하면 메모리 주소를 복사히가때문에 보다 적은 메모리를 가져오고
		//주소값을 들고있기 때문에 현재 Data구조체 내부 필드요소값을 변경할수 있다.

		var data Data
		//포인터 변수도 크기가 있다.
		//32bite 컴퓨터에서는 4bite의 크기를 받는다.
		//64bit 에서는 8bite를 받는다.

		//데이터의 주소를 넣어줘야한다.
		//이렇게 하면 1604bite를 복사하는게 아니라 8bite만 복사한다.
		POinterChange(&data)////data의 변수값이 아니라 data의 메모리 주소를 인수로 전달.
		fmt.Printf("value = %d\n", data.value)
		fmt.Printf("data[100] = %d\n", data.data[100])

		


		///////////////////////////////////////////////////////////////////////////////////////////////
		//var data Data
		//

		// //인수로 데이터를 넣어준것
		// ChangeData(data)

		// fmt.Printf("value = %d\n", data.value)
		// fmt.Printf("data[100] = %d\n", data.data[100])
		// //함수의 매개변수인 아규먼트와 데이터변수는 다른공간에 있는 변수다 라고생각하면된다.
		////////////////////////////////////////////////////////////////////////////////////////////



	//구조체를 이용해서 원하는 데이터를 출력해보세요 구조체를 이용하세요!!
	//영화가 됐던 뭐가됐던 뽑아봐라!!

}

/*

*에스터리스크???

포인터를 잘쓰면 성능상에 이점이 굉장히 많다 포인터를 지배하는자가 프로그램을 지배한다
메모리를 지배하는자가 프로그램을 지배한다.
포인터 그럼 언제써야되는것이냐 ??
우리가 여태까지 변수대입이라던가 함수 아규먼트 전달할때는 항상 값을 복사한다고했다.
1bite 2bite....상관없다

인수전달 변수대입 많은 메모리공간을 소비하게된다. 그리고 값이 크다 큰 메모리공간을 복사할때는 
성능상에 문제가된다.

다른공간에 아이에 복사를 하는거라 변경사항이 적용이 안된다.



 */