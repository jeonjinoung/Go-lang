package main

import (
	"fmt"
	"sync"
	"time"
)

func PrintChar() {
	char := []rune{'대', '한', '민', '국', '코', '리', '아'}

	//time : 시간과 관련된 
	for _, v := range char {
		time.Sleep(300* time.Millisecond)//300ms 
		fmt.Printf("%c", v)
	}
}

func PrintNum(){
	for i := 1; i < 5; i++ {
		time.Sleep(400*time.Millisecond)//400ms 
		fmt.Printf("%d", i)
	}
}
//전역변수 프로그램이 종료되면 날라가는 변수 
var wg sync.WaitGroup

func Sum(a,b int){
	sum:=0
	for i := a; i <= b; i++ {
		sum += i
	}
	fmt.Printf("%d부터 %d까지의 합 %d.\n", a,b,sum)
	
	wg.Done()//작업이 완료됨 / //작업이 완료될때마다 호출 
}


func main() {
////////////////////////////////////////////////////////////////////
	//go 함수이름 / 실행하는 새로운 고루틴을 실행해준다.
	//호출된 함수는 -> 현재의 고루틴이 아니라 새로운 고루틴에서 수행된다.

	// go PrintChar()//새로운 고루틴
	// go PrintNum()//새로운 고루틴

	// time.Sleep(3 * time.Second)
	//메인루틴에서 고루틴이 완료될때까지 3초간 대기해주는것
	//메인함수가 종료되면 아무리 많은 고루틴이 있다고하더라고 호출되지않는다.

	//고루틴이 언제종료되는지 매번 알수 없을때 사용되는 패키지
	//sync패키지 - waitGroup 이녀섴을 쓰면 된다.
///////////////////////////////////////////////////////////////////

	/////////////////////////////////////////////////////
	// 실행안함
	// var wg sync.WaitGroup

	// wg.Add(5)//작업 개수 설정 / 작업개수를 5개를 넣었다.
	// wg.Done()//작업이 완료 될때마다 호출 / 
	// wg.Wait()//모든 작업이 완료 될때까지 대기

	wg.Add(10)//개수 설정 / 작업개수 10개를 넣었다.
	for i := 0; i < 10; i++ {
		go Sum(1,1000000)
	}

	wg.Wait()//모든 작업이 끝날때까지 기다리자

	//고루틴이 10개다 라는것이다.
	/////////////////////////////////////////////////////


}

/*
모든 프로그램은 고루틴을 최소 하나 가지고있다. \
메인 루틴 메인함수랑 같이 시작됨
메인함수가 종료되면 종료된다.

C에서 짜면 20~30줄짜야한다.

//go 함수이름 실행하는 새로운 고루틴을 실행해준다.


속기사
Go로 만든 프로그램 역시 os위에서 당연히 돌아간다 명령을 수행하려면 당연히
os쓰레드를 만들어서 수행해준다.
////////////////////
만약에 메인루틴만 존재한다.


///////////////////////////
컨텍스트 스위칭이라는게 있다.
Cpu가 쓰레드를 변경할때 발생을 한다
어쨌든 메모리의 자원적인 부분에서 소리가 생긴다
컨텍스트 스위치 비용이 발생되지않는다. 고루틴만 변경된다.

*/