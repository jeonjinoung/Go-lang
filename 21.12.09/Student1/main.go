package main

///////////////////////////////////////////////////////////////
//단일책임원칙

//객체 구조체 책임
// type EnglishReport struct{
// 	report string
// }

// type MathReport struct{
// 	report string
// }

// //send보내주는 책임
// func(r* EnglishReport)sendReport(e string){

// }
// //EnglishReport소속된 sandReport는 쓸수 없다 왜냐면 MathReport에 속해있는게아니라
// //EnglishReport소속되어 있기 때문이다.

// func(r* MathReport)sendReport(e string){

// }
//리포트메서드를 포함한 인터페이스
// type Report interface{
// 	Report() string
// }

// type EnglishReport struct{
// 	report string
// }

// //Report()인터페이스 구현
// func(r *EnglishReport) Report(e string){
// 	return r.report
// }

// type ReportSend struct{
// 	sdafsdafdsafsa
// }

// func(s *ReportSend)sendReport(report Report){
// 	//리포트 인터페이스 객체를 인수로 받는다.
// }

////////////////////////////////////////////////////////////////
//개방태새원칙에 위반된다.

//방식에 따라서 흔히 볼수있는
//case문만 작성을해주면되죠? 즉 이말은 기존 sendReport라는 함수를 변경하게된다.
//어떤type에따라서 추가된다는것은
// func sendReport(r *Report, method sendType, receiver string){
// 	switch method{
// 	case Printer:
// 	case Email:
// 	...
// 	}
// }
//////////////////////////////////////////////////////////////////////////
//Reportsend를 구현하는 구조체
//새기능을 추가했지만 기존에 있는 기능을 변경하지않아도 된다.
// type ReportSend interface{
// 	send(r *Report)
// }

// type Email struct{}
// func(e *Email) send(r* Report){

// }

// type Printer struct{}
// func(e *Printer) send(r* Report){

// }
///////////////////////////////////////////////////////////////////////
//인터페이스 분리의 원칙
//인터페이스를 좀더 가볍게 쓸수 있다라는것
//매서드 3개를 들고있따.
// type Report interface{
// 	Report()string
// 	Page()int //불필요한 메서드
// 	Write()string //불필요한 메서드
// 	//싹다 분리시켜버리면된다.
// }
// //적은수의 메서드를 가지고있는 인터페이스가 여러개 있는게 좋다. == 불필요한 메서드를 여러가지 가지고있는 인터페이스보다

// type Report interface{
// 	Report()string
// }
// //불필요한 메서드의 관계를 끊어버린것
// type Write interface{
// 	Page()int//불필요한 메서드
// 	Write()string//불필요한 메서드
// }
// //함수를 봤더니 3개중에서 하나만쓰고있다. 인터페이스를 불필요하게 포함하고잇다.
// func sendReport(r Report){
// 	send(r. Report())
// }
///////////////////////////////////////////////////////////////////////////
//의존관계 역전 원칙
/*
상위 계층이 하위 계층에 의존하는 전통적인 의존관계를 역전시킴으로서
상위 계층이 하위 계층의 구현으로부터 독립되게한다.
//
1. 상위모듈은 하위모듈에 의존 x둘다 추상모듈에 의존해야함
(결함도가 낮아지므로 다른프로그램의 이식성이 증가한다.)
2. 추상 모듈은 구체화된 모듈에 의존해서는 안된다. 구체화된 모듈은 추상 모듈에 의존해야한다.

속기사
top down방식
우리는 이러한 방식이 익숙해져있기때문에 위에서 아래로 코드를 짜고 문제또한 그렇게 찾는다.
input을 받고 그데이터를 네트워크 밖으로 보내는 방식을 본다면 이렇게 되지않습니까?
키보드가 있지않습니까? 키보드의 받은 입력을 넷트워크로 전송한다. 이런겁니다. 자
이 여기에서의 전송이라고 한다면 이 동작은 어떻게 되겠냐?? 동작의 원리는 키보드의 입력을 받는다.
값을 읽은다음에 이 넷트워크라는 하위모듈로 값이 쓰여진다는것을 알수 있겠지

설계원칙에 따르자면 반전을 시켜줘야하는데 어떻게하는것이냐?
둘 다 추상화 모듈에 의존을 해야한다 인터페이스를 이용하면된다.
중요하죠? 키보드랑 입력이라는것을 추상모듈로 구현을한다면 이렇게된다.

의존관계를 분리시켜버림
그러면 자기 본유의 기능에 충실하게된다.const
키보든 말그대로 뭐겠어 입력이라는 기능만 신경쓰면됨
전송은 입력과 출력을 연결해주는 공간
독립성이 유지된다는것은 다음 프로젝트에 그 기능을 붙여도 된다는것이다.
코드 재상용성이 높아진다는것이다.
//
*/
func main() {


	

}

/*
속기사
코드 일부분을 다른 프로젝트에서 쓰고싶다
모듈간의 결합도가 높으면 내가 다음프로젝트에 쓸수없다
그럼 코드가 재사용확률이 적어진다.
그럼 하드코등해야한다. = 같은 기능을 계속만들어야한다.
결함도가 높은것은 -> 들어내서 따른쪽으로 옮길수가 없다.
하나의 모듈이 동립적이지못하고 의존적인 관계가 있을때
좋은설계는 뭐겠어 내가 방금 말한게 뭐겟어
결함도가 낮고 응집도가 높은 설계??
어떻게하면 좋은설계를 할수 잇는것이냐?
어떤녀섴이든 제일 처음에 나온 객체가 중요하다.

단일 책임 원칙
: 모든 객체는 책임을 하나만 져야한다. 독립적이어야한다.!!
코드 재사용성을 높여준다.

속기사
간단하죠 ??심플하고 근데 코드를 짜다보면 굉장히 유실되기시운게 이녀섴이다.
말그대로 보고서를 감당하는 객체 
인터페이스라는 녀섴을 써주면된다 인터페이스를 이용하는 관계를 형성해주면된다.



*/
